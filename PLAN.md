# PostgreSQL to SQLite Migration Plan

## Overview
Migrate production PostgreSQL database backup (`backup_cadeianominal.sql`) to SQLite for local development environment.

**Source**: PostgreSQL 15.13 dump (23,731 lines)
**Target**: SQLite database for Django development
**Reference**: https://stackoverflow.com/questions/6148421/how-to-convert-a-postgres-database-to-sqlite

---

## Prerequisites

### Required Tools
- [x] Python 3.x with Django 5.2.3
- [ ] `pgloader` (recommended for automated conversion)
- [ ] PostgreSQL client tools (psql, pg_dump) - already available
- [ ] SQLite3 command-line tool
- [ ] Text editor or sed/awk for SQL transformations

### Installation Commands
```bash
# Ubuntu/Debian
sudo apt-get install pgloader sqlite3

# macOS
brew install pgloader sqlite3
```

---

## Migration Strategy

### Option 1: Django-Native Approach (Recommended for Development)
**Use Django's built-in data migration tools** - Most reliable, maintains referential integrity.

#### Advantages
✅ Preserves Django model relationships automatically
✅ Handles Django-specific fields (JSONField, AutoField, etc.)
✅ No manual SQL transformation needed
✅ Validates data against current models

#### Steps
1. **Restore PostgreSQL backup to temporary database**
   ```bash
   # Create temporary PostgreSQL database
   createdb temp_cadeia_dominial

   # Restore backup
   psql temp_cadeia_dominial < backup_cadeianominal.sql
   ```

2. **Export data using Django's dumpdata**
   ```bash
   # Configure Django to use PostgreSQL temporarily
   export DJANGO_SETTINGS_MODULE=cadeia_dominial.settings_prod
   export DATABASE_URL=postgresql://cadeia_user:password@localhost/temp_cadeia_dominial

   # Export all data to JSON fixtures
   python manage.py dumpdata \
     --natural-foreign \
     --natural-primary \
     --exclude contenttypes \
     --exclude auth.permission \
     --indent 2 \
     > data_export.json
   ```

3. **Switch to SQLite and import data**
   ```bash
   # Switch back to development settings (SQLite)
   export DJANGO_SETTINGS_MODULE=cadeia_dominial.settings

   # Delete existing SQLite database
   rm -f db.sqlite3

   # Create fresh database with migrations
   python manage.py migrate

   # Load exported data
   python manage.py loaddata data_export.json
   ```

4. **Verify migration**
   ```bash
   # Run Django shell to check data
   python manage.py shell
   ```
   ```python
   from dominial.models import TIs, Imovel, Documento, Lancamento

   print(f"TIs count: {TIs.objects.count()}")
   print(f"Imovel count: {Imovel.objects.count()}")
   print(f"Documento count: {Documento.objects.count()}")
   print(f"Lancamento count: {Lancamento.objects.count()}")
   ```

---

### Option 2: pgloader (Automated SQL Conversion)
**Use pgloader for direct database-to-database migration** - Faster for large datasets.

#### Advantages
✅ Automated conversion process
✅ Handles most PostgreSQL → SQLite differences
✅ Good for large databases

#### Disadvantages
❌ May require manual fixes for PostgreSQL-specific features
❌ Less control over transformation process

#### Steps
1. **Restore PostgreSQL backup**
   ```bash
   createdb temp_cadeia_dominial
   psql temp_cadeia_dominial < backup_cadeianominal.sql
   ```

2. **Create pgloader configuration**
   Create `migration.load`:
   ```lisp
   LOAD DATABASE
     FROM postgresql://cadeia_user:password@localhost/temp_cadeia_dominial
     INTO sqlite://db.sqlite3

   WITH include drop, create tables, create indexes, reset sequences

   SET work_mem to '16MB', maintenance_work_mem to '512 MB';
   ```

3. **Run pgloader**
   ```bash
   pgloader migration.load
   ```

4. **Verify and fix issues**
   - Check for PostgreSQL extensions (pg_trgm, uuid-ossp) that need manual handling
   - Validate Django migrations compatibility
   - Test application functionality

---

### Option 3: Manual SQL Transformation
**Transform PostgreSQL SQL dump to SQLite-compatible SQL** - Most control, most work.

#### Steps
1. **Extract data-only from PostgreSQL**
   ```bash
   pg_dump -U cadeia_user \
     --data-only \
     --column-inserts \
     temp_cadeia_dominial > data_only.sql
   ```

2. **Transform SQL syntax** (create `transform_sql.sh`)
   ```bash
   #!/bin/bash

   cat data_only.sql \
     | sed 's/public\.//g' \
     | sed 's/OWNER TO [^;]*;//g' \
     | sed 's/SET.*//g' \
     | sed 's/SELECT pg_catalog.*//g' \
     | sed "s/true/1/g" \
     | sed "s/false/0/g" \
     | sed 's/GENERATED BY DEFAULT AS IDENTITY/AUTOINCREMENT/g' \
     | grep -v '^--' \
     | grep -v '^COMMENT' \
     | grep -v '^ALTER TABLE.*OWNER' \
     | grep -v 'CREATE EXTENSION' \
     > sqlite_compatible.sql
   ```

3. **Apply to SQLite**
   ```bash
   # Backup existing database
   cp db.sqlite3 db.sqlite3.backup

   # Import transformed SQL
   sqlite3 db.sqlite3 < sqlite_compatible.sql
   ```

4. **Manual fixes required**
   - PostgreSQL `serial` → SQLite `INTEGER PRIMARY KEY AUTOINCREMENT`
   - PostgreSQL `uuid` → SQLite `TEXT` (if UUIDs are used)
   - PostgreSQL arrays → SQLite JSON or separate tables
   - PostgreSQL `timestamp with time zone` → SQLite `TEXT` (ISO 8601 format)
   - Remove PostgreSQL-specific extensions (pg_trgm, uuid-ossp)

---

## Critical Considerations

### PostgreSQL vs SQLite Differences

| Feature | PostgreSQL | SQLite | Migration Action |
|---------|-----------|--------|------------------|
| **Extensions** | pg_trgm, uuid-ossp | Not supported | Remove or replace with app logic |
| **IDENTITY** | GENERATED BY DEFAULT AS IDENTITY | AUTOINCREMENT | Let Django migrations handle |
| **Sequences** | Explicit sequences | Implicit | Django ORM manages |
| **UUID** | Native UUID type | TEXT | Django UUIDField handles automatically |
| **Boolean** | true/false | 1/0 | Django BooleanField handles |
| **JSON** | Native JSONB | TEXT with JSON1 extension | Django JSONField compatible |
| **Constraints** | CHECK, EXCLUDE | CHECK only | Review EXCLUDE constraints |

### Django-Specific Concerns

1. **Migrations Compatibility**
   - SQLite database must match current migration state
   - Run `python manage.py migrate` before importing data
   - Use `--fake-initial` if schema already exists

2. **Model Fields**
   - Check for PostgreSQL-specific fields (ArrayField, HStoreField, JSONField)
   - Verify unique constraints work in SQLite (especially `unique_together`)
   - Test CASCADE deletion behavior (Imovel → Documento → Lancamento)

3. **Settings Configuration**
   ```python
   # settings.py (development with SQLite)
   DATABASES = {
       'default': {
           'ENGINE': 'django.db.backends.sqlite3',
           'NAME': BASE_DIR / 'db.sqlite3',
       }
   }

   # settings_prod.py (production with PostgreSQL) - already configured
   ```

---

## Recommended Workflow

### Phase 1: Preparation (15-30 min)
1. ✅ Install required tools (pgloader, postgresql-client)
2. ✅ Backup current SQLite database: `cp db.sqlite3 db.sqlite3.backup`
3. ✅ Review backup file structure: `head -500 backup_cadeianominal.sql`
4. ✅ Document current SQLite row counts for comparison

### Phase 2: Temporary PostgreSQL Setup (5-10 min)
1. ✅ Create temporary database: `createdb temp_cadeia_dominial`
2. ✅ Restore backup: `psql temp_cadeia_dominial < backup_cadeianominal.sql`
3. ✅ Verify data: `psql temp_cadeia_dominial -c "SELECT COUNT(*) FROM dominial_tis;"`

### Phase 3: Django Data Export (10-20 min)
1. ✅ Configure Django for PostgreSQL temporarily
2. ✅ Run dumpdata: `python manage.py dumpdata > data_export.json`
3. ✅ Verify JSON file size and structure
4. ⚠️ **Warning**: Large datasets may need chunked exports by app/model

### Phase 4: SQLite Import (5-15 min)
1. ✅ Delete current SQLite: `rm db.sqlite3`
2. ✅ Run migrations: `python manage.py migrate`
3. ✅ Load fixtures: `python manage.py loaddata data_export.json`
4. ✅ Handle errors (especially FK constraints, missing dependencies)

### Phase 5: Validation (15-30 min)
1. ✅ Compare row counts (PostgreSQL vs SQLite)
2. ✅ Test key features:
   - TIs detail pages
   - Documento creation/editing
   - Lancamento forms
   - Cadeia dominial tree visualization
3. ✅ Run Django tests: `python manage.py test`
4. ✅ Check admin interface functionality

### Phase 6: Cleanup (5 min)
1. ✅ Drop temporary database: `dropdb temp_cadeia_dominial`
2. ✅ Remove large JSON export: `rm data_export.json`
3. ✅ Document any manual fixes needed
4. ✅ Update README with migration notes

---

## Troubleshooting Guide

### Common Issues

#### Issue 1: Foreign Key Constraint Failures
**Symptom**: `IntegrityError: FOREIGN KEY constraint failed`
**Cause**: Data loaded in wrong order (child before parent)
**Solution**: Use `--natural-foreign` flag in dumpdata, or disable constraints temporarily:
```python
# In loaddata command, temporarily:
from django.db import connection
cursor = connection.cursor()
cursor.execute('PRAGMA foreign_keys=OFF;')
# ... load data ...
cursor.execute('PRAGMA foreign_keys=ON;')
```

#### Issue 2: JSONField Compatibility
**Symptom**: `OperationalError: no such column: json_extract`
**Cause**: Old SQLite version without JSON1 extension
**Solution**: Upgrade SQLite to 3.9.0+ or avoid JSON queries in development

#### Issue 3: UUID Field Errors
**Symptom**: `ValueError: badly formed hexadecimal UUID string`
**Cause**: PostgreSQL UUID format differs from SQLite text representation
**Solution**: Django's UUIDField handles this automatically; ensure using Django ORM, not raw SQL

#### Issue 4: Sequence Reset Issues
**Symptom**: Duplicate primary key errors on new inserts
**Cause**: SQLite autoincrement counter not updated after data import
**Solution**: Run after import:
```sql
UPDATE sqlite_sequence SET seq = (SELECT MAX(id) FROM table_name) WHERE name='table_name';
```

#### Issue 5: Large Export File
**Symptom**: Out of memory errors during dumpdata
**Cause**: Dataset too large for single JSON file
**Solution**: Export by app or model:
```bash
# Export in chunks
python manage.py dumpdata dominial.TIs > tis.json
python manage.py dumpdata dominial.Imovel > imovel.json
python manage.py dumpdata dominial.Documento > documento.json
python manage.py dumpdata dominial.Lancamento > lancamento.json

# Load in correct order (respecting FKs)
python manage.py loaddata tis.json
python manage.py loaddata imovel.json
python manage.py loaddata documento.json
python manage.py loaddata lancamento.json
```

---

## Validation Checklist

### Data Integrity
- [ ] Row counts match between PostgreSQL and SQLite
- [ ] Primary key sequences are correct
- [ ] Foreign key relationships intact
- [ ] Unique constraints working (Documento: numero + cartorio)
- [ ] Cascade deletion works (Imovel → Documento → Lancamento)

### Application Functionality
- [ ] Django admin interface works
- [ ] TIs list and detail pages load
- [ ] Cadeia dominial tree visualization renders
- [ ] Document creation/editing forms work
- [ ] Lancamento forms submit successfully
- [ ] Autocomplete fields function properly

### Data Accuracy
- [ ] Sample TIs data matches production
- [ ] Document numbers and dates correct
- [ ] Pessoa names and relationships preserved
- [ ] Cartorio assignments accurate
- [ ] Transaction history complete

### Performance
- [ ] Page load times acceptable (<2s for detail pages)
- [ ] Tree visualization renders smoothly
- [ ] Admin queries performant (with SQLite limitations noted)

---

## Alternative: Docker PostgreSQL for Development

**Consider keeping PostgreSQL for development** to match production environment exactly.

### Quick Setup
```bash
# Use existing docker-compose.dev.yml
docker-compose -f docker-compose.dev.yml up -d

# Restore backup
docker exec -i cadeia-db psql -U cadeia_user -d cadeia_dominial < backup_cadeianominal.sql

# Configure Django
export DJANGO_SETTINGS_MODULE=cadeia_dominial.settings_prod
export DATABASE_URL=postgresql://cadeia_user:cadeia_password@localhost:5432/cadeia_dominial

# Run development server
python manage.py runserver
```

### Advantages
✅ Exact production parity
✅ PostgreSQL-specific features available
✅ No migration complexity
✅ Better testing accuracy

### Disadvantages
❌ Requires Docker daemon
❌ Slightly higher resource usage
❌ More complex setup for new developers

---

## Recommended Decision Tree

```
START
 │
 ├─ Need exact production parity?
 │   └─ YES → Use Docker PostgreSQL (skip migration)
 │
 ├─ Have large dataset (>10K records)?
 │   └─ YES → Use pgloader (Option 2)
 │
 ├─ Want maximum Django compatibility?
 │   └─ YES → Use Django dumpdata/loaddata (Option 1) ✅ RECOMMENDED
 │
 └─ Need fine control over transformation?
     └─ YES → Manual SQL transformation (Option 3)
```

---

## Final Recommendation

**Use Option 1: Django-Native Approach**

**Rationale**:
1. ✅ Most reliable for Django applications
2. ✅ Handles model relationships automatically
3. ✅ Validates against current codebase
4. ✅ Standard Django workflow
5. ✅ Easy to repeat if needed

**Estimated Time**: 1-2 hours total (including validation)

**Risk Level**: Low (can always restore from backup)

---

## Post-Migration Tasks

### Update Documentation
- [ ] Add migration notes to README.md
- [ ] Document any PostgreSQL-specific features removed
- [ ] Update development setup instructions

### Update Settings
- [ ] Verify DATABASES settings in settings.py
- [ ] Confirm feature flags work with SQLite
- [ ] Test DUPLICATA_VERIFICACAO_ENABLED functionality

### Team Communication
- [ ] Notify team of database change
- [ ] Share migration procedure for other developers
- [ ] Document any behavioral differences in SQLite vs PostgreSQL

---

## Rollback Plan

If migration fails or causes issues:

```bash
# Restore original SQLite database
cp db.sqlite3.backup db.sqlite3

# Or start fresh
rm db.sqlite3
python manage.py migrate
python manage.py createsuperuser
python manage.py criar_tipos_documento
python manage.py criar_tipos_lancamento

# Fallback: Use Docker PostgreSQL
docker-compose -f docker-compose.dev.yml up -d
export DJANGO_SETTINGS_MODULE=cadeia_dominial.settings_prod
```

---

## References

- [StackOverflow: PostgreSQL to SQLite conversion](https://stackoverflow.com/questions/6148421/how-to-convert-a-postgres-database-to-sqlite)
- [Django Documentation: Fixtures](https://docs.djangoproject.com/en/5.2/howto/initial-data/)
- [pgloader Documentation](https://pgloader.readthedocs.io/)
- [SQLite vs PostgreSQL Comparison](https://www.sqlite.org/whentouse.html)
- Django Project: `CLAUDE.md` (this repository)

---

**Created**: 2026-01-07
**Author**: Claude Code
**Version**: 1.0
**Status**: Ready for execution
